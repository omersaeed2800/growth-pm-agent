import pandas as pd
import os
from datetime import datetime

# File path for metrics storage
METRICS_FILE = "metrics.csv"

def initialize_metrics_file():
    """
    Initialize the metrics CSV file with headers if it doesn't exist.
    This ensures we have a proper file structure from the start.
    """
    if not os.path.exists(METRICS_FILE):
        # Create DataFrame with column structure
        df = pd.DataFrame(columns=[
            'timestamp',
            'user_id',
            'metric_type',
            'value'
        ])
        # Save to CSV
        df.to_csv(METRICS_FILE, index=False)
        print(f"Created new metrics file: {METRICS_FILE}")

def track_metric(user_id: str, metric_type: str, value: float):
    """
    Track a growth metric to the CSV file.
    
    Args:
        user_id: Unique identifier for the user (generated by session_state)
        metric_type: Type of metric ('activation', 'engagement', 'retention', 'satisfaction')
        value: Numeric value of the metric
    
    Metric Types:
        - activation: 1 if user has used the tool (tracked once per user)
        - engagement: 1 for each strategy created
        - retention: 1 if user returns after 1 week (tracked by separate script)
        - satisfaction: Rating value from 1-5
    """
    
    # Initialize file if it doesn't exist
    initialize_metrics_file()
    
    # Create new metric entry
    new_metric = {
        'timestamp': datetime.now().isoformat(),
        'user_id': user_id,
        'metric_type': metric_type,
        'value': value
    }
    
    # Read existing metrics
    try:
        df = pd.read_csv(METRICS_FILE)
    except (FileNotFoundError, pd.errors.EmptyDataError):
        df = pd.DataFrame(columns=['timestamp', 'user_id', 'metric_type', 'value'])
    
    # Append new metric
    df = pd.concat([df, pd.DataFrame([new_metric])], ignore_index=True)
    
    # Save back to CSV
    df.to_csv(METRICS_FILE, index=False)
    
    print(f"Tracked {metric_type} metric for user {user_id[:8]}... with value {value}")

def load_metrics():
    """
    Load all metrics from the CSV file.
    
    Returns:
        pandas DataFrame with all metrics, or empty DataFrame if no data
    """
    
    initialize_metrics_file()
    
    try:
        df = pd.read_csv(METRICS_FILE)
        
        # Convert timestamp to datetime
        if not df.empty and 'timestamp' in df.columns:
            df['timestamp'] = pd.to_datetime(df['timestamp'])
        
        return df
    
    except (FileNotFoundError, pd.errors.EmptyDataError):
        # Return empty DataFrame with correct columns
        return pd.DataFrame(columns=['timestamp', 'user_id', 'metric_type', 'value'])

def save_feedback(user_id: str, rating: int):
    """
    Save user satisfaction rating (1-5 stars).
    
    Args:
        user_id: Unique user identifier
        rating: Satisfaction rating from 1 to 5
    """
    
    if rating < 1 or rating > 5:
        print(f"Warning: Invalid rating {rating}. Must be between 1 and 5.")
        return
    
    # Track satisfaction metric
    track_metric(
        user_id=user_id,
        metric_type='satisfaction',
        value=rating
    )
    
    print(f"Saved satisfaction rating: {rating} stars")

def calculate_retention_rate():
    """
    Calculate 1-week retention rate.
    
    This function identifies users who:
    1. Used the tool (have activation metric)
    2. Returned after 7+ days
    
    Returns:
        Dictionary with retention statistics
    """
    
    df = load_metrics()
    
    if df.empty:
        return {
            'total_users': 0,
            'retained_users': 0,
            'retention_rate': 0.0
        }
    
    # Get all users who activated (used the tool)
    activated_users = df[df['metric_type'] == 'activation']['user_id'].unique()
    total_users = len(activated_users)
    
    if total_users == 0:
        return {
            'total_users': 0,
            'retained_users': 0,
            'retention_rate': 0.0
        }
    
    # Check which users returned after 7 days
    retained_users = []
    
    for user in activated_users:
        user_metrics = df[df['user_id'] == user].sort_values('timestamp')
        
        if len(user_metrics) > 1:
            # Get first and last activity timestamps
            first_activity = user_metrics.iloc[0]['timestamp']
            last_activity = user_metrics.iloc[-1]['timestamp']
            
            # Calculate days between activities
            days_diff = (last_activity - first_activity).days
            
            # If user returned after 7+ days, count as retained
            if days_diff >= 7:
                retained_users.append(user)
    
    retained_count = len(retained_users)
    retention_rate = (retained_count / total_users) * 100
    
    return {
        'total_users': total_users,
        'retained_users': retained_count,
        'retention_rate': retention_rate
    }

def get_summary_stats():
    """
    Get summary statistics for all growth metrics.
    
    Returns:
        Dictionary with key metrics
    """
    
    df = load_metrics()
    
    if df.empty:
        return {
            'total_users': 0,
            'activation_rate': 0.0,
            'total_strategies': 0,
            'avg_satisfaction': 0.0,
            'retention_rate': 0.0
        }
    
    # Calculate metrics
    total_users = df['user_id'].nunique()
    activated_users = df[df['metric_type'] == 'activation']['user_id'].nunique()
    activation_rate = (activated_users / total_users * 100) if total_users > 0 else 0
    
    total_strategies = df[df['metric_type'] == 'engagement']['value'].sum()
    
    satisfaction_df = df[df['metric_type'] == 'satisfaction']
    avg_satisfaction = satisfaction_df['value'].mean() if not satisfaction_df.empty else 0
    
    retention_stats = calculate_retention_rate()
    
    return {
        'total_users': total_users,
        'activation_rate': activation_rate,
        'total_strategies': int(total_strategies),
        'avg_satisfaction': avg_satisfaction,
        'retention_rate': retention_stats['retention_rate']
    }

def export_metrics_report(filename: str = None):
    """
    Export a formatted metrics report to CSV.
    
    Args:
        filename: Optional custom filename. Defaults to metrics_report_[date].csv
    """
    
    if filename is None:
        filename = f"metrics_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    
    df = load_metrics()
    
    if df.empty:
        print("No metrics to export.")
        return
    
    # Add some calculated columns for the report
    report_df = df.copy()
    report_df['date'] = pd.to_datetime(report_df['timestamp']).dt.date
    
    # Save report
    report_df.to_csv(filename, index=False)
    print(f"Metrics report exported to {filename}")
    
    return filename
